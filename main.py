import asyncio
import os
from aiogram import Bot, Dispatcher, types, F
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.types import KeyboardButton, ReplyKeyboardMarkup
from dotenv import load_dotenv

# –ó–∞–≤–∞–Ω—Ç–∞–∂—É—î–º–æ —Ç–æ–∫–µ–Ω –∑ .env
load_dotenv()
TOKEN = os.getenv("TOKEN")
if not TOKEN:
    raise RuntimeError("‚ùå –ù–µ –∑–Ω–∞–π–¥–µ–Ω–æ —Ç–æ–∫–µ–Ω! –î–æ–¥–∞–π –π–æ–≥–æ —É —Ñ–∞–π–ª .env")

# –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è –±–æ—Ç–∞
bot = Bot(token=TOKEN)
dp = Dispatcher(storage=MemoryStorage())

# –°—Ç–∞–Ω –º–∞—à–∏–Ω–∏
class TestStates(StatesGroup):
    choosing_section = State()
    in_test = State()

# –ì–ª–æ–±–∞–ª—å–Ω–∞ –∑–º—ñ–Ω–Ω–∞ –¥–ª—è –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è –æ–±—Ä–∞–Ω–æ–≥–æ —Ä–æ–∑–¥—ñ–ª—É
user_section = {}

# –ú–µ–Ω—é
menu_keyboard = ReplyKeyboardMarkup(
    keyboard=[
        [KeyboardButton(text="–û–ø"), KeyboardButton(text="–•–∞—Ä–¥–¢–µ—Å—Ç")],
        [KeyboardButton(text="–ó–∞–≥–∞–ª—å–Ω—ñ"), KeyboardButton(text="–õ—ñ–Ω")]
    ],
    resize_keyboard=True
)

@dp.message(F.text.in_({"–û–ø", "–•–∞—Ä–¥–¢–µ—Å—Ç", "–ó–∞–≥–∞–ª—å–Ω—ñ", "–õ—ñ–Ω"}))
async def start_quiz(message: types.Message, state: FSMContext):
    section = message.text
    await state.set_state(TestStates.in_test)
    user_section[message.from_user.id] = section
    await message.answer(f"–ü–æ—á–∏–Ω–∞—î–º–æ —Ç–µ—Å—Ç '{section}'! ‚ùó –Ü–Ω—à—ñ —Ä–æ–∑–¥—ñ–ª–∏ —Ç–∏–º—á–∞—Å–æ–≤–æ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ñ.")
    # –¢—É—Ç –º–∞—î –±—É—Ç–∏ –ª–æ–≥—ñ–∫–∞ —Ç–µ—Å—Ç—É–≤–∞–Ω–Ω—è‚Ä¶

@dp.message(TestStates.in_test)
async def handle_during_test(message: types.Message, state: FSMContext):
    await message.answer("üõë –ó–∞–≤–µ—Ä—à—ñ—Ç—å —Ç–µ—Å—Ç, –ø–µ—Ä—à –Ω—ñ–∂ –ø–µ—Ä–µ—Ö–æ–¥–∏—Ç–∏ –¥–æ —ñ–Ω—à–∏—Ö –¥—ñ–π.")

@dp.message(TestStates.choosing_section)
async def choose_section(message: types.Message, state: FSMContext):
    await message.answer("–û–±–µ—Ä–∏ —Ä–æ–∑–¥—ñ–ª:", reply_markup=menu_keyboard)

@dp.message()
async def default(message: types.Message, state: FSMContext):
    await state.set_state(TestStates.choosing_section)
    await message.answer("–ü—Ä–∏–≤—ñ—Ç! –û–±–µ—Ä–∏ —Ä–æ–∑–¥—ñ–ª —Ç–µ—Å—Ç—É:", reply_markup=menu_keyboard)

# –ó–∞–ø—É—Å–∫
if __name__ == "__main__":
    asyncio.run(dp.start_polling(bot))class HardTestState(StatesGroup):
    question_index = State()
    selected_options = State()

def main_keyboard():
    buttons = [types.KeyboardButton(text=section) for section in sections]
    buttons.append(types.KeyboardButton(text="üëÄHard TestüëÄ"))
    return types.ReplyKeyboardMarkup(keyboard=[[btn] for btn in buttons], resize_keyboard=True)

@dp.message(F.text == "/start")
async def cmd_start(message: types.Message, state: FSMContext):
    await state.clear()
    await message.answer("–í–∏–±–µ—Ä–∏ —Ä–æ–∑–¥—ñ–ª –¥–ª—è —Ç–µ—Å—Ç—É:", reply_markup=main_keyboard())

@dp.message(F.text.in_(sections.keys()))
async def start_quiz(message: types.Message, state: FSMContext):
    data = await state.get_data()
    if data.get("active_test"):
        await message.answer(f"‚ùó –í–∏ –≤–∂–µ –ø—Ä–æ—Ö–æ–¥–∏—Ç–µ —Ç–µ—Å—Ç —É —Ä–æ–∑–¥—ñ–ª—ñ: {data['active_test']}. –ó–∞–≤–µ—Ä—à—ñ—Ç—å –π–æ–≥–æ, –±—É–¥—å –ª–∞—Å–∫–∞.")
        return

    category = message.text
    questions = sections[category]

    await state.set_state(QuizState.category)
    await state.update_data(category=category, question_index=0, selected_options=[], questions=questions, active_test=category)

    await message.answer(f"üîí –ü–æ—á–∞—Ç–æ —Ä–æ–∑–¥—ñ–ª: {category}", reply_markup=types.ReplyKeyboardRemove())
    await send_question(message, state)

@dp.message(F.text == "üëÄHard TestüëÄ")
async def start_hard_test(message: types.Message, state: FSMContext):
    data = await state.get_data()
    if data.get("active_test"):
        await message.answer(f"‚ùó –í–∏ –≤–∂–µ –ø—Ä–æ—Ö–æ–¥–∏—Ç–µ —Ç–µ—Å—Ç —É —Ä–æ–∑–¥—ñ–ª—ñ: {data['active_test']}. –ó–∞–≤–µ—Ä—à—ñ—Ç—å –π–æ–≥–æ, –±—É–¥—å –ª–∞—Å–∫–∞.")
        return

    shuffled_questions = hard_questions.copy()
    random.shuffle(shuffled_questions)

    await state.set_state(HardTestState.question_index)
    await state.update_data(
        question_index=0,
        selected_options=[],
        questions=shuffled_questions,
        active_test="üëÄHard TestüëÄ"
    )

    await message.answer("üîí –ü–æ—á–∞—Ç–æ —Ä–æ–∑–¥—ñ–ª: Hard Test", reply_markup=types.ReplyKeyboardRemove())
    await send_hard_question(message, state)

async def send_question(message_or_callback, state: FSMContext):
    data = await state.get_data()
    questions = data.get("questions")
    index = data.get("question_index", 0)

    if index >= len(questions):
        await message_or_callback.answer("–¢–µ—Å—Ç –∑–∞–≤–µ—Ä—à–µ–Ω–æ!", reply_markup=main_keyboard())
        await state.update_data(active_test=None)
        await state.clear()
        return

    q = questions[index]
    keyboard = types.InlineKeyboardMarkup(row_width=1)
    for i, opt in enumerate(q["options"]):
        keyboard.add(types.InlineKeyboardButton(text=opt, callback_data=f"ans_{i}"))

    await message_or_callback.answer(q["question"], reply_markup=keyboard)

@dp.callback_query(lambda c: c.data and c.data.startswith("ans_"))
async def process_answer(callback: types.CallbackQuery, state: FSMContext):
    selected = int(callback.data.split("_")[1])
    data = await state.get_data()
    questions = data.get("questions")
    index = data.get("question_index", 0)

    q = questions[index]
    # –ú–æ–∂–Ω–∞ —Ç—É—Ç –∑–±–µ—Ä–µ–≥—Ç–∏ —á–∏ –ø–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ –ø—Ä–∞–≤–∏–ª—å–Ω—ñ—Å—Ç—å, —è–∫—â–æ –ø–æ—Ç—Ä—ñ–±–Ω–æ

    index += 1
    await state.update_data(question_index=index)

    await callback.answer()  # –ü—Ä–∏–±–∏—Ä–∞—î "–≥–æ–¥–∏–Ω–∫—É" –≤ Telegram

    await send_question(callback.message, state)

async def send_hard_question(message_or_callback, state: FSMContext):
    data = await state.get_data()
    questions = data.get("questions")
    index = data.get("question_index", 0)

    if index >= len(questions):
        await message_or_callback.answer("Hard Test –∑–∞–≤–µ—Ä—à–µ–Ω–æ!", reply_markup=main_keyboard())
        await state.update_data(active_test=None)
        await state.clear()
        return

    q = questions[index]
    keyboard = types.InlineKeyboardMarkup(row_width=1)
    for i, opt in enumerate(q["options"]):
        keyboard.add(types.InlineKeyboardButton(text=opt, callback_data=f"hard_ans_{i}"))

    await message_or_callback.answer(q["question"], reply_markup=keyboard)

@dp.callback_query(lambda c: c.data and c.data.startswith("hard_ans_"))
async def process_hard_answer(callback: types.CallbackQuery, state: FSMContext):
    selected = int(callback.data.split("_")[2])
    data = await state.get_data()
    index = data.get("question_index", 0)
    index += 1
    await state.update_data(question_index=index)

    await callback.answer()

    await send_hard_question(callback.message, state)

if __name__ == "__main__":
    import asyncio
    asyncio.run(dp.start_polling(bot))async def start_quiz(message: types.Message, state: FSMContext):
    data = await state.get_data()
    if data.get("active_test"):
        await message.answer(f"‚ùó –í–∏ –≤–∂–µ –ø—Ä–æ—Ö–æ–¥–∏—Ç–µ —Ç–µ—Å—Ç —É —Ä–æ–∑–¥—ñ–ª—ñ: {data['active_test']}. –ó–∞–≤–µ—Ä—à—ñ—Ç—å –π–æ–≥–æ, –±—É–¥—å –ª–∞—Å–∫–∞.")
        return

    category = message.text
    questions = sections[category]

    await state.set_state(QuizState.category)
    await state.update_data(category=category, question_index=0, selected_options=[], questions=questions, active_test=category)

    await message.answer(f"üîí –ü–æ—á–∞—Ç–æ —Ä–æ–∑–¥—ñ–ª: {category}", reply_markup=types.ReplyKeyboardRemove())
    await send_question(message, state)

@dp.message(F.text == "üëÄHard TestüëÄ")
async def start_hard_test(message: types.Message, state: FSMContext):
    data = await state.get_data()
    if data.get("active_test"):
        await message.answer(f"‚ùó –í–∏ –≤–∂–µ –ø—Ä–æ—Ö–æ–¥–∏—Ç–µ —Ç–µ—Å—Ç —É —Ä–æ–∑–¥—ñ–ª—ñ: {data['active_test']}. –ó–∞–≤–µ—Ä—à—ñ—Ç—å –π–æ–≥–æ, –±—É–¥—å –ª–∞—Å–∫–∞.")
        return

    shuffled_questions = hard_questions.copy()
    random.shuffle(shuffled_questions)

    await state.set_state(HardTestState.question_index)
    await state.update_data(
        question_index=0,
        selected_options=[],
        questions=shuffled_questions,
        active_test="üëÄHard TestüëÄ"
    )

    await message.answer("üîí –ü–æ—á–∞—Ç–æ —Ä–æ–∑–¥—ñ–ª: Hard Test", reply_markup=types.ReplyKeyboardRemove())
    await send_hard_question(message, state)

async def send_question(message_or_callback, state: FSMContext):
    data = await state.get_data()
    questions = data.get("questions")
    index = data.get("question_index", 0)

    if index >= len(questions):
        await message_or_callback.answer("–¢–µ—Å—Ç –∑–∞–≤–µ—Ä—à–µ–Ω–æ!", reply_markup=main_keyboard(message_or_callback.from_user.id))
        await state.update_data(active_test=None)
        await state.clear()
        return

    q = questions[index]
    keyboard = types.InlineKeyboardMarkup(row_width=1)
    for i, opt in enumerate(q["options"]):
        keyboard.add(types.InlineKeyboardButton(text=opt, callback_data=f"ans_{i}"))

    await message_or_callback.answer(q["question"], reply_markup=keyboard)

@dp.callback_query(lambda c: c.data and c.data.startswith("ans_"))
async def process_answer(callback: types.CallbackQuery, state: FSMContext):
    selected = int(callback.data.split("_")[1])
    data = await state.get_data()
    questions = data.get("questions")
    index = data.get("question_index", 0)

    q = questions[index]
    correct = q["correct"]

    # –¢—É—Ç –º–æ–∂–Ω–∞ –∑–±–µ—Ä—ñ–≥–∞—Ç–∏ –≤–∏–±—ñ—Ä, —Ä–∞—Ö—É–≤–∞—Ç–∏ –±–∞–ª–∏ —ñ —Ç.–¥.
    # –î–ª—è –ø—Ä–æ—Å—Ç–æ—Ç–∏ ‚Äî –ø—Ä–æ—Å—Ç–æ —ñ–¥–µ–º–æ –¥–æ –Ω–∞—Å—Ç—É–ø–Ω–æ–≥–æ –ø–∏—Ç–∞–Ω–Ω—è
    index += 1
    await state.update_data(question_index=index)

    await callback.answer()  # —â–æ–± –ø—Ä–∏–±—Ä–∞—Ç–∏ "–≥–æ–¥–∏–Ω–∫—É" –≤ Telegram

    # –í—ñ–¥–ø—Ä–∞–≤–ª—è—î–º–æ –Ω–∞—Å—Ç—É–ø–Ω–µ –ø–∏—Ç–∞–Ω–Ω—è
    await send_question(callback.message, state)

async def send_hard_question(message_or_callback, state: FSMContext):
    data = await state.get_data()
    questions = data.get("questions")
    index = data.get("question_index", 0)

    if index >= len(questions):
        await message_or_callback.answer("Hard Test –∑–∞–≤–µ—Ä—à–µ–Ω–æ!", reply_markup=main_keyboard(message_or_callback.from_user.id))
        await state.update_data(active_test=None)
        await state.clear()
        return

    q = questions[index]
    keyboard = types.InlineKeyboardMarkup(row_width=1)
    for i, opt in enumerate(q["options"]):
        keyboard.add(types.InlineKeyboardButton(text=opt, callback_data=f"hard_ans_{i}"))

    await message_or_callback.answer(q["question"], reply_markup=keyboard)

@dp.callback_query(lambda c: c.data and c.data.startswith("hard_ans_"))
async def process_hard_answer(callback: types.CallbackQuery, state: FSMContext):
    selected = int(callback.data.split("_")[2])
    data = await state.get_data()
    index = data.get("question_index", 0)
    index += 1
    await state.update_data(question_index=index)

    await callback.answer()

    await send_hard_question(callback.message, state)

def main_keyboard(user_id=None):
    buttons = [types.KeyboardButton(text=section) for section in sections]
    buttons.append(types.KeyboardButton(text="üëÄHard TestüëÄ"))
    return types.ReplyKeyboardMarkup(keyboard=[[btn] for btn in buttons], resize_keyboard=True)

@dp.message(F.text == "/start")
async def cmd_start(message: types.Message, state: FSMContext):
    await state.clear()
    await message.answer("–í–∏–±–µ—Ä–∏ —Ä–æ–∑–¥—ñ–ª –¥–ª—è —Ç–µ—Å—Ç—É:", reply_markup=main_keyboard(message.from_user.id))

if __name__ == "__main__":
    import asyncio
    asyncio.run(dp.start_polling(bot))
def main_keyboard(user_id=None):
    buttons = [types.KeyboardButton(text=section) for section in sections]
    buttons.append(types.KeyboardButton(text="üëÄHard TestüëÄ"))
    if user_id in ADMIN_IDS:
        buttons.append(types.KeyboardButton(text="‚ÑπÔ∏è –Ü–Ω—Ñ–æ"))
    return types.ReplyKeyboardMarkup(keyboard=[[btn] for btn in buttons], resize_keyboard=True)

@dp.message(F.text == "/start")
async def cmd_start(message: types.Message, state: FSMContext):
    user = message.from_user
    user_id = user.id

    if is_blocked(user_id):
        await message.answer("üö´–ë–æ—Ç —Ç–∏–º—á–∞—Å–æ–≤–æ –Ω–µ–ø—Ä–∞—Ü—é—îüîê")
        return

    await state.clear()
    await message.answer("–í–∏–±–µ—Ä–∏ —Ä–æ–∑–¥—ñ–ª –¥–ª—è —Ç–µ—Å—Ç—É:", reply_markup=main_keyboard(user_id))

@dp.message(F.text.in_(sections.keys()))
async def start_quiz(message: types.Message, state: FSMContext):
    user_id = message.from_user.id
    if is_blocked(user_id):
        await message.answer("üö´–ë–æ—Ç —Ç–∏–º—á–∞—Å–æ–≤–æ –Ω–µ–ø—Ä–∞—Ü—é—îüîê")
        return

    category = message.text
    questions = sections[category]

    from main import log_result, save_user_if_new
    log_result(message.from_user, category, started=True)

    await state.set_state(QuizState.category)
    await state.update_data(category=category, question_index=0, selected_options=[], wrong_answers=[], questions=questions)

    await message.answer(f"üîí –ü–æ—á–∞—Ç–æ —Ä–æ–∑–¥—ñ–ª: {category}", reply_markup=types.ReplyKeyboardRemove())
    await send_question(message, state)

@dp.message(F.text == "üëÄHard TestüëÄ")
async def start_hard_test(message: types.Message, state: FSMContext):
    user_id = message.from_user.id
    if is_blocked(user_id):
        await message.answer("üö´–ë–æ—Ç —Ç–∏–º—á–∞—Å–æ–≤–æ –Ω–µ–ø—Ä–∞—Ü—é—îüîê")
        return

    from main import log_result, save_user_if_new
    log_result(message.from_user, "üëÄHard TestüëÄ", started=True)

    await state.clear()
    await state.set_state(HardTestState.question_index)

    shuffled_questions = hard_questions.copy()
    random.shuffle(shuffled_questions)

    await state.update_data(
        category="üëÄHard TestüëÄ",
        question_index=0,
        selected_options=[],
        temp_selected=set(),
        questions=shuffled_questions
    )

    await message.answer("üîí –ü–æ—á–∞—Ç–æ —Ä–æ–∑–¥—ñ–ª: Hard Test", reply_markup=types.ReplyKeyboardRemove())
    await send_hard_question(message.chat.id, state)

# üîÅ –û–±—Ä–æ–±–∫–∞ –∫–Ω–æ–ø–∫–∏ "–ü—Ä–æ–π—Ç–∏ —â–µ —Ä–∞–∑" ‚Äî –ó–í–ò–ß–ê–ô–ù–ò–ô –¢–ï–°–¢
@dp.callback_query(F.data == "restart")
async def restart_quiz(callback: CallbackQuery, state: FSMContext):
    data = await state.get_data()
    category = data.get("category")

    if not category or category not in sections:
        await state.clear()
        await callback.message.answer("‚ö†Ô∏è –í–∏–Ω–∏–∫–ª–∞ –ø–æ–º–∏–ª–∫–∞. –û–±–µ—Ä—ñ—Ç—å —Ä–æ–∑–¥—ñ–ª –∑–∞–Ω–æ–≤–æ:", reply_markup=main_keyboard(callback.from_user.id))
        return

    questions = sections[category][:]
    await state.clear()
    await state.set_state(QuizState.category)
    await state.update_data(
        category=category,
        question_index=0,
        selected_options=[],
        wrong_answers=[],
        questions=questions
    )
    await callback.message.answer(f"üîÑ –ü–æ—á–∏–Ω–∞—î–º–æ —Ä–æ–∑–¥—ñ–ª —â–µ —Ä–∞–∑: {category}", reply_markup=types.ReplyKeyboardRemove())
    await send_question(callback, state)

# üîÅ –û–±—Ä–æ–±–∫–∞ –∫–Ω–æ–ø–∫–∏ "–ü—Ä–æ–π—Ç–∏ —â–µ —Ä–∞–∑" ‚Äî HARD TEST
@dp.callback_query(F.data == "hard_retry")
async def restart_hard_quiz(callback: CallbackQuery, state: FSMContext):
    await state.clear()
    await state.set_state(HardTestState.question_index)

    shuffled_questions = hard_questions.copy()
    random.shuffle(shuffled_questions)

    await state.update_data(
        category="üëÄHard TestüëÄ",
        question_index=0,
        selected_options=[],
        temp_selected=set(),
        questions=shuffled_questions
    )
    await callback.message.answer("üîÑ –ü–æ—á–∏–Ω–∞—î–º–æ Hard Test —â–µ —Ä–∞–∑!", reply_markup=types.ReplyKeyboardRemove())
    await send_hard_question(callback.message.chat.id, state)

# ‚úÖ –ü–æ–≤–µ—Ä–Ω–µ–Ω–Ω—è –∫–ª–∞–≤—ñ–∞—Ç—É—Ä–∏ –ø—ñ—Å–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—è (–∑–≤–∏—á–∞–π–Ω–∏–π —Ç–µ—Å—Ç)
# –í –∫—ñ–Ω–µ—Ü—å —Ñ—É–Ω–∫—Ü—ñ—ó send_question (–∫–æ–ª–∏ —Ç–µ—Å—Ç –∑–∞–≤–µ—Ä—à–µ–Ω–æ):
# await message_or_callback.answer("–¢–µ—Å—Ç –∑–∞–≤–µ—Ä—à–µ–Ω–æ", reply_markup=main_keyboard(user_id))

# ‚úÖ –ü–æ–≤–µ—Ä–Ω–µ–Ω–Ω—è –∫–ª–∞–≤—ñ–∞—Ç—É—Ä–∏ –ø—ñ—Å–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—è (hard test)
# –í –∫—ñ–Ω–µ—Ü—å send_hard_question –ø—ñ—Å–ª—è –Ω–∞–¥—Å–∏–ª–∞–Ω–Ω—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç—É:
# await bot.send_message(chat_id, "–í–∏–±–µ—Ä–∏ —Ä–æ–∑–¥—ñ–ª:", reply_markup=main_keyboard(user.id))
